#include <iostream>

struct a
{
	int x;
	virtual void f() = 0;
};

struct b : virtual a 
{};

struct c : virtual a
{}; 

struct d : b, c //будет два x, от b и от c
{
	virtual void f() {}
};

int main() {
	d dd;
	// dd.x; //не работает
	dd.b::x; //:: -- синтаксис разыменования scope
	//при виртуальном наследовании предки склеиваются. Если f была перегружена в c, 
	//но не перегружена в b, то при обычном наследовании в d она тоже будет не 
	//перегружена, потому что будет путь до не перегруженной через b. Если их склеить, 
	//то перегрузка в одном из предков будет ок
	//	a 			a a
	// / \ 			| |
	// b c вместо 	b c
	//  \/			\ /
	//	d 			 d
	//но при этом при виртуальном наследовании если реализовать и в b, и в с, но не 
	//написать будет ошибка компиляции. Но если при этом написать отдельно 
	//и в d, то будет норм
	//если прописано в обоих предках, но не написано в d, то можно 
	//сказать c::f() или d::f()


	a& aa = dd; //error, если наследование не virtual
	// a& aa = (b&) dd; //будет работаеть и при обычном наследовании


	return 0;
}